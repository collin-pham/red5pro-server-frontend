<html lang="en">
<head>
<title>WebRTC Publisher</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="author" content="Paul Gregoire">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<link rel="stylesheet" type="text/css" href="default.css">
<script src="RTCPeerConnection-v1.6.js"></script>
<script type="text/javascript">
    "use strict"
    // keep track of who we are publisher-wise
    var streamName = getQueryVariable('streamName');
    var appName = getQueryVariable('app') || 'webrtc';
    var host = getQueryVariable('host') || location.hostname;
    // our channel / room name
    var channelName = getQueryVariable('channelId');
    // primary peer which sends to the server, not other peers
    var clientPeer;
    // the MediaStream
    var clientStream;
    // configure ice / turn/stun uris
    var ice = [];
    if (window.moz) {
/*
        ice.push({
            urls: 'stun:' + location.hostname + ':3478'
        });
        ice.push({
            urls: 'turn:' + location.hostname + ':3478?transport=udp', credential: 'webrtc', username: 'webrtc'
        });
*/
        // mozilla STUN
        ice.push({
            urls: 'stun:stun.services.mozilla.com:3478'
        });
    } else {
/*
        ice.push({
            url: 'stun:' + location.hostname + ':3478'
        });
        ice.push({
            url: 'turn:' + location.hostname + ':3478?transport=udp',
            credential: 'webrtc',
            username: 'webrtc'
        });
*/
        // google STUN (1...4)
        ice.push({
            url: 'stun:stun2.l.google.com:19302'
        });
    }
    // communication channel
    var wsprotocol = location.protocol == 'https:' ? 'wss' : 'ws';
    var wsport = location.protocol == 'https:' ? '8083' : '8081';
    var context = channelName ? appName + '/' + channelName : appName;
    var socket = new WebSocket(wsprotocol + '://' + host + ':' + wsport + '/' + context + '?id=' + streamName);
    // called when the socket opens; this opens the channel / room
    socket.onopen = function() {
      console.log('Socket opened');
    };

    // messages coming from the websocket
    socket.onmessage = function(message) {
      console.log(message);
      if (message.data) {
        var json = JSON.parse(message.data);
        if (json.isAvailable !== undefined) {
          console.log('Message - isAvailable: ' + json.isAvailable);
          if (json.isAvailable===true) {
            // start the peer negotiation process between the peers
            alert(json.streamName + ' is already published');
          } else {
            console.log('Stream is not published');
            createPeer();
          }
        }
        if (json.data !== undefined) {
          if (json.data.message !== undefined) {
            console.log('Message: ' + json.data.message);
            if (json.data.type === 'error') {
              if (json.data.detail) {
                alert('Error: ' + json.data.message + '\n' + json.data.detail);
              } else {
                alert('Error: ' + json.data.message);
              }
            }
          }
          // data for the client peer
          if (json.data.sdp !== undefined) {
            if (json.data.sdp.type === 'answer') {
              console.log('Received answer');
              clientPeer.addAnswerSDP(json.data.sdp);
            }
          }
          if (json.data.candidate !== undefined) {
            console.log('Received candidate');
            clientPeer.addICE({
              sdpMid: json.data.candidate.sdpMid,
              sdpMLineIndex: json.data.candidate.sdpMLineIndex,
              candidate: json.data.candidate.candidate
            });
          }
        }
      } else {
        console.warn('No message data');
      }
    };

    // closes the websocket
    function closeSocket() {
      if (socket !== undefined) {
        closeParticipant();
        // close
        setTimeout(function(){
          console.log('Closing the socket');
          socket.close();
        }, 1000);
      }
    }

    // resets the video element and clears the reference to the MediaStream
    function resetParticipant(id) {
      if (window.moz) {
        document.getElementById(id + '_vid')['mozSrcObject'] = undefined;
      } else {
        document.getElementById(id + '_vid')['src'] = "";
      }
    }

    // checks to see if a stream is being published by name
    function checkStreamAvailable() {
      console.log('Availability check');
      if (socket !== undefined) {
        socket.send(JSON.stringify({
          isAvailable: streamName,
          type: 'webrtc',
          bundle: false
        }));
      }
    }

    // creates the send-only peer with the server app
    function createPeer() {
      clientPeer = RTCPeerConnection({
        constraints : window.moz ? { offerToReceiveVideo:false, offerToReceiveAudio:false } : { mandatory: { offerToReceiveVideo:false, offerToReceiveAudio:false }},
        attachStream : clientStream,
        iceServers: ice,
        onICE : function(candidate) {
          console.log('Sending candidate');
          socket.send(JSON.stringify({
            handleCandidate: streamName,
            data: {
              candidate: candidate
            }
          }));
        },
        onOfferSDP : function(sdp) {
          console.log('Sending offer: ' + sdp);
          socket.send(JSON.stringify({
            handleOffer: streamName,
            data: {
              sdp: sdp
            }
          }));
        }
      });
    }

    function publish() {
      console.log('Sending publish request');
      socket.send(JSON.stringify({
        publish: streamName
      }));
    }

    // used to mute the speakers for the publish stream
    function muteParticipant(id) {
      if (arguments.length == 0) {
        id = streamName;
      }
      console.log('Mute: ' + id);
      var video = document.getElementById(id + '_vid');
      if (!video.muted) {
        console.log('Mute audio: ' + id);
        video.muted = true;
      } else {
        console.log('Unmute audio: ' + id);
        video.muted = false;
      }
    }

    function closeParticipant() {
      console.log('Closing / stopping: ' + streamName);
      resetParticipant(streamName);
      // if we've got a socket and we're closing our publish stream
      if (socket !== undefined) {
        console.log('Sending unpublish request');
        socket.send(JSON.stringify({
          unpublish: streamName
        }));
      }
    }

    function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; i++) {
            var pair = vars[i].split('=');
            if (decodeURIComponent(pair[0]) == variable) {
                return decodeURIComponent(pair[1]);
            }
        }
        console.log('Query variable ' + variable + ' not found');
    }

    function log(id, message) {
      console.log(id + ' - ' + message);
    }
</script>
</head>
<body>
<div id="container"></div>
<script type="text/javascript">

    // construct the divs
    var div = document.createElement('div');
    div.id = streamName;
    div.style.cssText = 'width:320px;height:240px;background:#eee;';
    document.getElementById('container').appendChild(div);
    var vid = document.createElement('video');
    vid.id = streamName + '_vid';
    vid.autoplay = true;
    document.getElementById(streamName).appendChild(vid);

    var audio_constraints = window.moz ? true : {
        mandatory: { googAutoGainControl:true, googHighpassFilter:true, googEchoCancellation:true, googNoiseSuppression:true },
        optional: [{ bandwidth:50 }, { echoCancellation:true }]
    };

    var video_constraints = {
        mandatory: { minWidth:320, minHeight:240, minFrameRate:4, maxWidth:640, maxHeight:480, maxFrameRate:24 },
        optional: [{ bandwidth:256 }, { googLeakyBucket:true }]
    };

    // getUserMedia
    function getUserMedia() {
        navigator.getUserMedia({audio:audio_constraints, video:video_constraints}, onsuccess,
          function(e) {
            console.error(e);
          }
        );
        function onsuccess(stream) {
            var video = document.getElementById(streamName + '_vid');
            if (video) {
                if (window.moz) {
                    video['mozSrcObject'] = stream;
                } else {
                    video['src'] = window.URL.createObjectURL(stream);
                }
                video.play();
            }
          clientStream = stream;
        }
    }

    getUserMedia();

</script>
<br /><br />
Control
<br />
<button id="checkAndCreate" onclick="checkStreamAvailable()">Create Peer</button>
<button id="publish" onclick="publish()">Publish</button>
<button id="mute" onclick="muteParticipant()">Mute</button>
<button id="closeAndExit" onclick="closeSocket()">Exit</button>
<br />
WebRTC Internals:
<a href="chrome://webrtc-internals" target="_blank">Chrome</a> |
<a href="about:webrtc" target="_blank">Firefox</a>
</body>
</html>
